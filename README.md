Yii2 intent analytics module
============================
Visitors intent analytics and integration with Google Analytics and Yandex.Metrika for Yii framework 2

[![Build Status](https://travis-ci.org/DevGroup-ru/yii2-intent-analytics.svg?branch=master)](https://travis-ci.org/DevGroup-ru/yii2-intent-analytics)
[![codecov.io](http://codecov.io/github/DevGroup-ru/yii2-intent-analytics/coverage.svg?branch=master)](http://codecov.io/github/DevGroup-ru/yii2-intent-analytics?branch=master)

## Install

```
composer require "devgroup/yii2-intent-analytics:*"
```

```bash
./yii migrate --migrationPath=vendor/devgroup/yii2-intent-analytics/src/migrations
```

### Configure your application

Add module:

```php
    'modules' => [
        ...
        'analytics' => [
            'class' => \DevGroup\Analytics\IntentAnalyticsModule::className(),
//            'detectFirstVisitSource' => true,
//            'detectAllVisitsSources' => true,
//            'storeLastActivity' => true,
//            'storeVisitedPages' => true,
//            'visitorCookieName' => 'visitor_id',
//            'visitorCookieTime' => 61516800,
//            'visitorCookieExpireTime' => 3758400,
//            'i18category' => 'IntentAnalyticsModule',
//            'modelMap' => [
//                'Visitor' => [
//                    'class' => 'DevGroup\Analytics\models\Visitor',
//                ],
//            ],
        ],
        ...
```
**Наброски документации, чтобы не забыть как все работает**

## Регистрация API клиентов
 
# Yandex

С ним все просто, несколько простых шагов, описанных вот [тут](https://tech.yandex.ru/metrika/) и можно работать.
В итоге, Яндекс дает `id клиента ` и `секрет клиента`. Эти данные используются для получения токена доступа к API.
В зависимости от типа приложения, срок жизни токена имеет разную величину. Для метрики - не меньше года.
Поэтому, единожды авторизовав приложение в админке можно работать, особо не задумываясь об актуальности токена.
С другой стороны, официальная библиотека на php не предоставляет возможности получить дату истечения токена, хотя OAuth 
сервер возвращает ее в теле ответа (PR?). И не предоставляет метода проверки токена на просроченность.
Из за этого возникает ряд моментов, которые следует продумать получше.
 
В общем, для авторизации клиента необходимо получить от Яндекса `id клиента ` и `секрет клиента` скопировать их в 
соответствующие поля в админке и нажать "Авторизовать".

Проверка клиента на предмет авторизованности присходит только по наличию токена доступа (вот тут-то и надо подумать).

# Google

С ним все сложнее.

Вопросы начинаются на этапе выбора типа доступа к API. Он предоставляет несколько вариантов.
Для нас их принципиальное различие заключается в том, что в некоторых случаям мы, как от Яндекса, получим 
`id клиента ` и `секрет клиента` и можем авторизовываться, а в другом мы получаем `*.json` файл, который необходимо
подгружать в момент инициализации клиента доступа к API.
Но проблема состоит в том, что при использовании `id клиента ` и `секрет клиента`
время жизни токена доступа  - час. После этого пользователь снова явным образом должен разрешить приложению доступ к 
своим данным.

В случае с `*.json` файлом и некоторыми типами приложений Google предоставляет постоянный токен (`refresh_token`) - токен для обновления 
временного для доступа. Используя его, можно без явного участия пользователя в фоне обновлять время жизни токена,
используя разрешения пользователя, полученные раньше.

Но и тут есть подвох -  `refresh_token` дается только один единственный раз, нигде в Google не хранится и не может быть 
восстановлен в случае чего.
В итоге имеем:
- создаем приложение и сервисные учетные данные [тут](https://console.developers.google.com/apis/credentials/wizard)
- добавляем учетные данные для доступа к API, используя "мастер создания учетных данных"
- при добавлении учетных данных тип приложения выбираем "WEB сервер, например Node.js или Tomcat"
- отмечаем, что хотим получать "данные пользователя" (?)
- указываем URL для редиректа после авторизации
- скачиваем `*.json` файл
- открываем его любым текстовым редактором
- копируем содержимое в поле "Учетные данные Json (Credentials Json)"
- авторизуем приложени.

После этих нехитрых шагов у нас в поле "Токен доступа (Access Token)" появятся, опять же `json` данные с токеном доступа.

В качестве токена доступа Google отдает `json`, который содержит главный временный токен, 
постоянный токен для обновления главноего временного и время до итсечения срока годности временного.

Благодаря этим данным мы имеем возможность получать правильные данные о годности токена и автоматически обновлять их без
явного участи япользователя.

# URL перенаправления после авторизации

В обоих случаях для авторизации используется стандарт OAuth2, с собственной реализацией для каждого из поставщиков API.

В обоих случаях для авторизации используется метод с обменом временного кода на токен доступа.

При создании приложения в каждом из поставщиков API необходимо указать URL для перенаправления вида:
 - `http://site.ru/analytics/counter-types/auth`
 
# Счетчики метрики

## Yandex

Яндекс позволяет [с помощью API получить код счтетчика](https://tech.yandex.ru/metrika/doc/api2/management/counters/counter-docpage/),
 поэтому, все что нужно сделать это:
- настроить яндекс метрику в панели управления Яндекса,
- скопировать оттуда инедтификатор счетчика, вида `ХХХХХХХХ`, где Х - какя-то цифра. Не нужно использовать идентификатор,
как в коде счетчика, вида `yaCounterXXXXXXXX`
- вставить его в соответствующее поле в админке "ID Счетчика"
- нажать "Получить HTML код счетчика"

Таким образом, код счетчика всегда будет иеть те настройки, которые были указаны в панели Яндекс.Метрики.
Единственное, необходимо после изменения настроек в метрике снова нажимать "Получить HTML код счетчика"

## Google

Google не предоставляет методов получения кодов счетчика по API (или я пока не нашел).
Вместо этого Google предоставляет [2 вида кода](https://developers.google.com/analytics/devguides/collection/analyticsjs/),
который осуществляет асинхронную подгрузку библиотеки `analytics.js`.

Второй вариант кода для современных браузеров будет храниться в `php` реализации класса для счетчика GoogleAnalytics
Все, что нужно сделать для получения счетчика:
- настроить аналдитику в консоли Google,
- скопировать оттуда инедтификатор счетчика, вида `'UA-XXXXX-Y'`,
- вставить его в соответствующее поле в админке "ID Счетчика",
- нажать "Получить HTML код счетчика",
- базовый код сгенерируется автоматически,
- дополнительные настройки можно дописать в готовом коде.

# Что есть и как работает

На текущий момент реализорано следующее:
- CRUD для типов счетчиков `/analytics/counter-types`, `/analytics/counter-types/edit?id=`. Тип счетчика по сути 
является записью, которая хранит токен доступа по API для Yandex или Google.   
- CRUD для счетчиков `/analytics/counters`, `/analytics/counters/edit?id=`. Счетчик - непосредственно счетчик метрики.
Он хранит:
    * название счетчика. С ним будет происходить инициализация js счетчиков. Инициализируя их с именами, можно
    легко избавить себя от боли, связанной с несколькими счетчиками на странице;
    * название js объекта (`ga`, `yaCounter`) - необходимо для корректной инициализации js счетчика. По этому названию
     будет искаться загруженный объект счетчика;
    * кнопка "Получить HTML код счетчика" в случае яндекса пойдет и по API забере HTML код счетчика, по пути подставив
     настройку, чтобы после успешной инициализации счетчик вызывал соответсвующее событие;
    * Если тип счетчика еще не авторизован - вместо "Получить HTML код счетчика", будет кнопка - "Авторизовать"
  
- виджет `DevGroup\Analytics\widgets\CountersWidget` он собирает из базы все автивные счетчики и события и инициализирует 
с ними js модуль `IntentAnalytics`, кроме того встраивает html коды счетчиков после открывающего `<body>` (согласно 
настойчивым рекомендациям Yandex и Google)
- на все активные события, заведенные в базе, при инициализации вешается обрабочик модуля `IntentAnalytics`. 

## `IntentAnalytics` модуль
Пытается как можно корректнее инициализировать и дождаться полной загрузки счетчиков.

### Yandex
Он по умолчанию не возбуждает никаких событий после загрузки. В консоли  метрики нет настройки для этого события, потому
при получении кода счетчки эту настройку приходится подставлять налету, чтобы не заморачивать пользователя.

Так же, Яндекс не имеет никаких очередей событий, которые собираются до того, как счетчик загружен и инициализирован.
Потому, работает импровизированная очередь, которая дожидается загрузки счетчика и после отправляет туда все то, что 
произошло, пока счетчик загружался. А дальше работает в обычном режиме.

### Google
Он возбуждает событие и имеет собственную очередь, потому в его случае все осуществляется штатными средаствами.

### Piwik
Он может быть двух видов: облачные метрики и метрики, установленные локально. Не ясно, что использовать.


   